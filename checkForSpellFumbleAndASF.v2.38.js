// async function anonymous(speaker,actor,token,character,scope,item,shared,action,state,startTime

/*	==========================================================================
	author: classicrp, @raydenx
	date: 2025-11-24
	==========================================================================
	<item> is passed in directly from the calling macro. required in order to
	set the dictionary value on said item.
	<actor> is passed in directly from the calling macro. required in order to
	set the dictionary value on said item.
	<shared> is passed in directly from the calling macro.  required in order
	to get the ChatasfContentPF object.
	returns: a string result, one of { 'CF', 'F', 'S', 'CS', '' }
	Thanks: to @Freeze, Discord::FVTT#macro-polo for reminding me that sometimes
	'get()' works better than 'filter()'
*/	
	const curVer = "v2.38";
	const head = `Macro.checkForSpellFumbleAndASF(${curVer}): `;
	let msg = "";
	let failState = false;
	//	========================================================= //

//	CHECK SECTION ========================================================

	//  to collect the result of the inspected spell attack
	let attackStatus = "", saved = false, normaAC = 0, acTouch = 0, acFF = 0;
	const isTouch = shared.action.touch; //	myvsAC.defaults.touch;

	const cRollData = shared.message.system.rolls.attacks[0].attack;	//	die roll data
	const cRnatural = cRollData.natural;								//  actual d20 roll
	const cRtotal = cRollData.total;									//	total
	let targets = null;
	//	target AC
	if (shared.targets.length == 0) {
		//	we don't have a target, do something about it
		let targetStatus = false;
		let lm = await game.macros.getName("Dialog-ok");
		targetStatus = await lm.execute();
		//	player canceled the dialog, no target selected.
		if (!targetStatus) {
			msg = "No target data available.  Exiting.";
			failState = true
			console.log(head + msg);
			return null;
		} else {
			targets = [...game.user.targets];
			//  no vsAC data available
			var tActor = game.actors.get(targets[0].document.actorId);
			acFF = tActor.system.attributes.ac.flatFooted.total;
			acNorm = tActor.system.attributes.ac.normal.total;
			acTouch= tActor.system.attributes.ac.touch.total;
			tActor = null;
		}
	} else {
		//	we have a target
		var myvsAC = shared.message.flags.vsAC;
		acFF = myvsAC.targets[0].ac.ff;
		acNorm = myvsAC.targets[0].ac.normal;
		acTouch = myvsAC.targets[0].ac.touch;
		myvsAC = null;
	}
	
	let cDc = 0, eqspLvl = 0;
	if (isTouch) {
		cDc = acTouch;
	} else {
		cDc = acNorm;
	}
    
debugger;

	//	check equivalent spell level.  DC = 15 + 2 * @sl
	const spLvl = item.system.level;
	eqspLvl = spLvl;
	// [0].value
	if (scope.shared.conditionals.length > 0) {
	//	some conditionals are present, check them out
		//	get the initial condition 
		let spCond = scope.action.conditionals.get(scope.shared.conditionals[0]);
		//	single out the name and convert case for ease in finding
		spCond = spCond.name.toLowerCase();
		//	break up the text at spaces into an array 
		spCond = spCond.split(" ");
		if (spCond.includes("lvl") || spCond.includes("level")) {
		//	must have "lvl" or "level" in the name
			
			//	initialize the string ordinal indicators array
			const ordInd = ["st", "rd", "nd", "th"];
			spCond.forEach(s => {
				ordInd.forEach(o => {
				//	filter for the value with an ordinal indicator
					if (s.includes(o)) {
					//	the first character in the number we are looking for
						eqspLvl = s.at(0);
					}
				});
			});
		}
	}

	let lm = await game.macros.getName("getRollStatus");
    attackStatus = await lm.execute({ total: cRtotal, roll: cRnatural, target: cDc });

	if (typeof attackStatus == "undefined") {
		//	TITLE WILL NOT BE DEFINED IF TYPE <> 'CHECK', SEE WHAT THE 'TITLE' OF CMSG ACTUALLY IS.
		failState = true;
		msg = `<p style="font-family: Arial, sans-serif; font-size: 1.1em;">Could not read the results of the <em>${item.name}</em> for <strong>${actor.name}</strong></p>`;
		ui.notifications.warn(msg);
		console.log(head + msg.slugify());

	} else if (attackStatus.amount == "CF") {
		//	now confirm failure by rolling a second time OR caster check?
		//	Spell Fumble
		
		lm = await game.macros.getName("spellFumble");
		await lm.execute({ shared: shared, args: eqspLvl });
	}

/*	ARCANE SPELL FAILURE SECTION ========================================== */

	/*	check for ASF here. Farm it out.  It needs;
	<actor._itemTypes.equipment> to dig up armor ASF values. Don't forget to 
			apply any feats that show up under "Effect Notes" or "Footnotes" 
			generated by said feats (i.e. "Arcane Armor Training" provides a
			-10% ASF [if activated as a swift action each round]).
	<shared.message.content>	contains the only reference to the "Arcane
			Spell Failure Check".
			
	*/
	const asfSearch = {
		lookingFor: `<h3>Arcane Spell Failure</h3>`, 
		hasFront: `<h4 class="dice-total`,
		ifSuccess: ` spell-failure ">`,
		ifFailure: ` spell-failure failure">`,
		hasBack: `</h4>`
	};
	const asfFeats = [
		{ hasFeat: `<span class="tag" data-tooltip="Source: Arcane Armor Mastery">`, 
			isAmount: -20 },
		{ hasFeat: `<span class="tag" data-tooltip="Source: Arcane Armor Training">`, 
			isAmount: -10 }
	];
	
	let asfContent = shared.message.content;
	let asfPresent = asfContent.includes(asfSearch.lookingFor);
	if (asfPresent) {
		//	lets collect the actor actual ASF
		let asfActor = actor.spellFailure;
		//	now check what was rolled vs. actual ASF
		let posS = asfContent.indexOf(asfSearch.lookingFor) + asfSearch.lookingFor.length;
		const posF = asfContent.indexOf(asfSearch.hasFront, posS);
		const posB = asfContent.indexOf(asfSearch.hasBack, posF);
		const asfCheck = asfContent.substring(posF, posB);
		const didFail = asfCheck.includes(asfSearch.ifFailure);
		let asfRoll = 0, asfLess = 0, i = 0;
		do {
			if (asfContent.includes(asfFeats[i].hasFeat)) {
				asfLess = asfFeats[i].isAmount;
			}
			++i;
		}
		while (asfLess === 0);
		if (didFail) {
			asfRoll = asfCheck.substring(asfSearch.hasFront.length + asfSearch.ifFailure.length);
			msg = `<span style="color: darkred">Failed</span> their <strong>Arcane Spell Failure</strong> check with a roll of [[${asfRoll}]] against an ASF of [[${asfActor + asfLess}]].`;
			ui.chat.processMessage(msg);
			//	Spell Fumble
			lm = await game.macros.getName("spellFumble");
			await lm.execute({ shared: shared, args: eqspLvl }); //armor: actor._itemTypes.equipment, content: shared.chatData.content, rolling: shared.asfContent.system.rolls.attacks[0].attack });
			
		} else {
			asfRoll = asfCheck.substring(asfSearch.hasFront.length + asfSearch.ifSuccess.length);
			msg = `<span style="color: cornflowerblue">Succeeded</span> their <strong>Arcane Spell Failure</strong> check with a roll of [[${asfRoll}]] against an ASF of [[${asfActor + asfLess}]].`;
			ui.chat.processMessage(msg);
		}
		
	}
	
	return attackStatus;